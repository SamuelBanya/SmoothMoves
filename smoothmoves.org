* Title
<2022-09-19 Mon 19:55>: After a bit of deliberation last night, I stumbled upon a decent name for this project, which would include the following:
- Smooth Moves

Reason being is that we used a similarly named moving company recently, and funnily enough, it was not as smooth as we expected so I aim to correct that with this app's experience.

* Ideas
<2022-09-19 Mon 19:56>: These are mentioned in the 'README.md' already for this project, but this is much more inclusive and thought out than my Phase 2 project so I'm already pretty stoked for where this is going as I would have loved to have this kind of app before I moved recently.

* Design Ideas
<2022-09-19 Mon 19:57>: This will include the following design choices:
- Usage of React based forms for the frontend
- "Material UI" will be used as the CSS stylesheet framework

* How I Installed The Backend Components
<2022-09-19 Mon 20:13>: I first used the following command to install the Gem components:
#+begin_src bash
bundle install
#+end_src

* How I Created The Separate Frontend
<2022-09-19 Mon 20:16>: As instructed by the assignment, I created a separate repo folder for the React frontend component:
- https://github.com/SamuelBanya/SmoothMoves-Frontend

I then changed into this directory, and then used the following terminal command:
#+begin_src bash
npx create-react-app smoothmoves-frontend
#+end_src

Related output:
#+BEGIN_SRC bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3 $ cd SmoothMoves-Frontend/
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend $ ls
LICENSE         README.md
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend $ npx create-react-app smoothmoves-frontend

Creating a new React app in /Users/samuelbanya/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1394 packages in 38s

209 packages are looking for funding
  run `npm fund` for details

Installing template dependencies using npm...

added 56 packages in 5s

209 packages are looking for funding
  run `npm fund` for details
Removing template package using npm...


removed 1 package, and audited 1450 packages in 2s

209 packages are looking for funding
  run `npm fund` for details

6 high severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.

Success! Created smoothmoves-frontend at /Users/samuelbanya/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd smoothmoves-frontend
  npm start

Happy hacking!
#+END_SRC

* How I Created The Related Migrations For The Related Tables
<2022-09-19 Mon 20:32>: I used the following migration command in terminal to create the necessary migration necessary for the 'User' table:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:create_migration NAME=create_users_table
db/migrate/20220920013221_create_users_table.rb
#+end_src

I then filled the contents of the 'db/migrate/20220920013221_create_users_table.rb' file with the following:
#+begin_src ruby
class CreateUsersTable < ActiveRecord::Migration[6.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

I then ran the related migration with the following 'bundle exec rake db:migrate' command:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateUsersTable: migrating =================================
-- create_table(:users)
   -> 0.0012s
== 20220920013221 CreateUsersTable: migrated (0.0013s) ========================
#+end_src

<2022-09-20 Tue 19:28>: I then created another migration for the 'items' table with the following 'bundle exec rake db:create_migration' command:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:create_migration NAME=create_items_table
db/migrate/20220921003339_create_items_table.rb
#+end_src

I then entered the following inside the 'db/migrate/20220921003339_create_items_table.rb' file:
#+begin_src ruby
class CreateItemsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :items do |t|
      t.string :name
      t.string :owner
      t.integer :length
      t.integer :width
      t.integer :height
      t.integer :weight
      # Values include "loose" or "boxed"
      t.string :item_type
    end
  end
end
#+end_src

I then ran the related migration for the 'bundle exec rake db:migrate' table with the following command:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0013s
== 20220921003339 CreateItemsTable: migrated (0.0013s) ========================
#+end_src

<2022-09-20 Tue 19:58>: I then thought about it for a bit, and realized I actually need a separate 'locations' table since all of the items would have two separate locations which include the 'dropoff_location' and 'pickup_location', so I created an associated migration accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:create_migration NAME=create_locations_table
db/migrate/20220921013908_create_locations_table.rb
#+end_src

I then modified the 'db/migrate/20220921013908_create_locations_table.rb' file with the following contents:
#+begin_src ruby
class CreateLocationsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :locations do |t|
      t.string :dropoff_location
      t.string :pickup_location
    end
  end
end
#+end_src

I then ran the following 'bundle exec rake db:migrate' command accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220921013908 CreateLocationsTable: migrating =============================
-- create_table(:locations)
   -> 0.0013s
== 20220921013908 CreateLocationsTable: migrated (0.0014s) ====================
#+end_src

I then created the following models under 'app/models':

'app/models/item.rb':
#+begin_src ruby
class Item < ActiveRecord::Base
end
#+end_src

'app/models/location.rb':
#+begin_src ruby
class Location < ActiveRecord::Base
end
#+end_src

'app/models/user.rb':
#+begin_src ruby
class User < ActiveRecord::Base
end
#+end_src

<2022-09-20 Tue 20:50>: I then determined the relationships involved in this particular scenario which include the following:
#+begin_src ascii
    ┌─────►Mover
    │
    │
User├─────►Item
    │
    │
    └─────►Location
#+end_src

<2022-09-20 Tue 21:00>: With this in mind, I then added another migration for the 'movers' table accordingly since each mover will have an associated 'name' and 'email' address for the '/email' route that we want to expose to the frontend later on:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:create_migration NAME=create_movers_table
db/migrate/20220921020149_create_movers_table.rb
#+end_src

I then added the following contents to the 'db/migrate/20220921020149_create_movers_table.rb' file:
#+begin_src ruby
class CreateMoversTable < ActiveRecord::Migration[6.1]
  def change
    create_table :movers do |t|
      t.string :name
      t.string :email
    end
  end
end
#+end_src

<2022-09-20 Tue 21:08>: I then thought of a neat feature to add later which would be the following:
- This would involve a slight bit of extra math, but you can basically do the following:
- Calculate the distance from the first set of movers to the 'pickup_location' which you can then list on the summary page
- Calculate the distance from the second set of movers to the 'dropoff_location' which you can then list on the summary page

I then ran the related migration with this command:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220921020149 CreateMoversTable: migrating ================================
-- create_table(:movers)
   -> 0.0015s
== 20220921020149 CreateMoversTable: migrated (0.0016s) =======================
#+end_src

I then added the associated 'app/models/mover.rb' model with the following contents:
#+begin_src ruby
class Mover < ActiveRecord::Base
end
#+end_src

<2022-09-21 Wed 13:40>: Notes From Office Hour Today:
- Add a 'owner_id' to the items table migration
- Drop the 'locations' table and just place it into users

<2022-09-21 Wed>: After talking about these table relationships with my instructor, Ryan Parrish, I realized that the following SQL table relationships make more sense and are exactly aligned to the requirements of the project itself:
- "users" table "has_many" "items"

This relationship itself is reciprocal and because it involves two separate models, it fulfills the requirements of the assignment which is the following:
- Have at least two models with a one-to-many relationship.

I then rolled back my migrations so that I could edit them accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921020149 CreateMoversTable: reverting ================================
-- drop_table(:movers)
   -> 0.0017s
== 20220921020149 CreateMoversTable: reverted (0.0046s) =======================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921013908 CreateLocationsTable: reverting =============================
-- drop_table(:locations)
   -> 0.0009s
== 20220921013908 CreateLocationsTable: reverted (0.0030s) ====================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921003339 CreateItemsTable: reverting =================================
-- drop_table(:items)
   -> 0.0009s
== 20220921003339 CreateItemsTable: reverted (0.0030s) ========================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220920013221 CreateUsersTable: reverting =================================
-- drop_table(:users)
   -> 0.0009s
== 20220920013221 CreateUsersTable: reverted (0.0035s) ========================
#+end_src

I then removed the 'app/models/location.rb' and 'app/models/mover.rb' models.

I then also removed their associated migrations as well.

I then revised the '20220920013221_create_users_table.rb' file so that a user has a 'dropoff_location' and a 'pickup_location':
#+begin_src ruby
class CreateUsersTable < ActiveRecord::Migration[6.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

I then revised the '20220921003339_create_items_table.rb' file to include the following contents:
#+begin_src ruby
class CreateItemsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :items do |t|
      t.string :name
      t.string :owner
      t.integer :length
      t.integer :width
      t.integer :height
      t.integer :weight
      # Values include "loose" or "boxed"
      t.string :item_type
    end
  end
end
#+end_src

I then re-ran the related 'bundle exec rake db:migrate' command accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateUsersTable: migrating =================================
-- create_table(:users)
   -> 0.0011s
== 20220920013221 CreateUsersTable: migrated (0.0012s) ========================

== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0010s
== 20220921003339 CreateItemsTable: migrated (0.0011s) ========================
#+end_src

I then revised the 'app/models/user.rb' file with the following contents:
#+begin_src ruby
class User < ActiveRecord::Base
    has_many :items
end
#+end_src

I then revised the 'app/models/item.rb' file with the following contents:
#+begin_src ruby
class Item < ActiveRecord::Base
    belongs_to :item
end
#+end_src

<2022-09-21 Wed 20:32>: I then realized I need to have some kind of 'id' based columns so that I can later use it for 'CRUD' type methods within the Application Controller.

With this in mind, I had to re-rollback the database again:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921003339 CreateItemsTable: reverting =================================
-- drop_table(:items)
   -> 0.0022s
== 20220921003339 CreateItemsTable: reverted (0.0052s) ========================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220920013221 CreateUsersTable: reverting =================================
-- drop_table(:users)
   -> 0.0012s
== 20220920013221 CreateUsersTable: reverted (0.0036s) ========================
#+end_src

I then revised the '20220920013221_create_users_table.rb' file with the following contents:
#+begin_src ruby
class CreateUsersTable < ActiveRecord::Migration[6.1]
  def change
    create_table :users do |t|
      t.integer :user_id
      t.string :name
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

I then revised the '20220921003339_create_items_table.rb' file with the following contents:
#+begin_src ruby
class CreateItemsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :items do |t|
      t.integer :item_id
      t.string :name
      t.string :owner
      t.integer :length
      t.integer :width
      t.integer :height
      t.integer :weight
      # Values include "loose" or "boxed"
      t.string :item_type
    end
  end
end
#+end_src

I then re-ran the 'db:migrate' command accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateUsersTable: migrating =================================
-- create_table(:users)
   -> 0.0013s
== 20220920013221 CreateUsersTable: migrated (0.0014s) ========================

== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0013s
== 20220921003339 CreateItemsTable: migrated (0.0014s) ========================
#+end_src
* How I Created CRUD Methods Within The Application Controller
<2022-09-21 Wed 21:26>: In order to add CRUD (Create, Read, Update, Delete) methods for the 'users' table, I modified the contents of the 'app/controllers/application_controller.rb' file with the following:
#+begin_src ruby
class ApplicationController < Sinatra::Base
  set :default_content_type, "application/json"

  # Add your routes here
  get "/" do
    { message: "Good luck with your project!" }.to_json
  end

  get "/users" do
    users = User.all()
    users.to_json()
  end

  post "/users" do
    user = User.create(
      name: params[:name],
      pickup_location: params[:pickup_location],
      dropoff_location: params[:dropoff_location]
    )
    user.to_json()
  end

  patch "/users/:id" do
    user = User.find(params[:user_id])
    user.update(
      name: params[:name],
      pickup_location: params[:pickup_location],
      dropoff_location: params[:dropoff_location]
    )
    user.to_json()
  end

  delete "/users/:id" do
    user = User.find(params[:user_id])
    user.destroy()
    user.to_json()
  end
end
#+end_src

I then modified the 'app/controllers/application_controller.rb' file with the following revisions to add "CRUD" methods for the "items" table:
#+begin_src ruby
class ApplicationController < Sinatra::Base
  set :default_content_type, "application/json"

  # Add your routes here
  get "/" do
    { message: "Good luck with your project!" }.to_json
  end

  get "/users" do
    users = User.all()
    users.to_json()
  end

  post "/users" do
    user = User.create(
      name: params[:name]
      pickup_location: params[:pickup_location]
      dropoff_location: params[:dropoff_location]
    )
    user.to_json()
  end

  patch "/users/:id" do
    user = User.find(params[:user_id])
    user.update(
      name: params[:name]
      pickup_location: params[:pickup_location]
      dropoff_location: params[:dropoff_location]
    )
    user.to_json()
  end

  delete "/users/:id" do
    user = User.find(params[:user_id])
    user.destroy()
    user.to_json()
  end

  get "/items" do
    items = Item.all()
    items.to_json()
  end

  post "/items" do
    item = Item.create(
      name: params[:name],
      owner: params[:owner],
      length: params[:length],
      width: params[:width],
      height: params[:height],
      weight: params[:weight],
      item_type: params[:item_type]
    )
    item.to_json()
  end

  patch "/items/:id" do
    item = Item.find(params[:item_id])
    item.update(
      name: params[:name],
      owner: params[:owner],
      length: params[:length],
      width: params[:width],
      height: params[:height],
      weight: params[:weight],
      item_type: params[:item_type]
    )
    item.to_json()
  end

  delete "/items/:id" do
    item = Item.find(params[:item_id])
    item.destroy()
    item.to_json()
  end
end
#+end_src


<2022-09-22 Thu 15:23>: Office Hour Notes:
- I first need to do two related rollbacks using 'bundle exec db:rollback'
- Then I need to make a correction to the key relationships since these are the corrections I need to make:
- This needs to include the following changes in the 'db/migrate/20220921003339_create_items_table.rb' migrations file to include the foreign key, ':user_id':
#+begin_src ruby
class CreateItemsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :items do |t|
      t.integer :user_id
      t.string :name
      t.string :owner
      t.integer :length
      t.integer :width
      t.integer :height
      t.integer :weight
      # Values include "loose" or "boxed"
      t.string :item_type
    end
  end
end
#+end_src
- I need to remove the ':user_id' key in the '20220920013221_create_users_table.rb' file:
#+begin_src ruby
class CreateUsersTable < ActiveRecord::Migration[6.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

<2022-09-22 Thu 15:28>: I then made these revisions and used 'bundle exec rake db:migrate':
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateUsersTable: migrating =================================
-- create_table(:users)
   -> 0.0013s
== 20220920013221 CreateUsersTable: migrated (0.0013s) ========================

== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0010s
== 20220921003339 CreateItemsTable: migrated (0.0011s) ========================
#+end_src

<2022-09-22 Thu 15:41>: Office Hour Notes:
- I had to rethink my app yet again because the way my current tables would not be valid as per project requirements
- This is because the current version of my app would assume there are multiple 'users', which is not the case since there is a singular user
- Therefore, I need to change the 'users' table to instead be 'moves' since you can track multiple moves within the single move application

With this in mind, I did two rollbacks yet again:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921003339 CreateItemsTable: reverting =================================
-- drop_table(:items)
   -> 0.0013s
== 20220921003339 CreateItemsTable: reverted (0.0039s) ========================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220920013221 CreateUsersTable: reverting =================================
-- drop_table(:users)
   -> 0.0010s
== 20220920013221 CreateUsersTable: reverted (0.0039s) ========================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
#+end_src

I then changed the name of the 'db/migrate/20220920013221_create_users_table.rb' file to the following name:
- 'db/migrate/20220920013221_create_moves_table.rb'

I then changed the contents of the 'db/migrate/20220920013221_create_moves_table.rb' file to the following:
#+begin_src ruby
class CreateMovesTable < ActiveRecord::Migration[6.1]
  def change
    create_table :users do |t|
      t.string :name
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

I then changed the contents of the '20220921003339_create_items_table.rb' file to the following:
#+begin_src ruby
class CreateItemsTable < ActiveRecord::Migration[6.1]
  def change
    create_table :items do |t|
      t.integer :move_id
      t.string :name
      t.string :owner
      t.integer :length
      t.integer :width
      t.integer :height
      t.integer :weight
      # Values include "loose" or "boxed"
      t.string :item_type
    end
  end
end
#+end_src

I then changed the 'app/models/user.rb' to the following name:
- 'app/models/move.rb'

I then changed the contents of the 'app/models/move.rb' file to the following:
#+begin_src ruby
class Move < ActiveRecord::Base
    has_many :items
end
#+end_src

I then ran the related migration again:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateMovesTable: migrating =================================
-- create_table(:users)
   -> 0.0010s
== 20220920013221 CreateMovesTable: migrated (0.0011s) ========================

== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0010s
== 20220921003339 CreateItemsTable: migrated (0.0011s) ========================
#+end_src

<2022-09-23 Fri 10:39>:

I realized I didn't name the 'moves' table correctly, so I had to roll it back yet again:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220921003339 CreateItemsTable: reverting =================================
-- drop_table(:items)
   -> 0.0012s
== 20220921003339 CreateItemsTable: reverted (0.0037s) ========================

samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:rollback
== 20220920013221 CreateMovesTable: reverting =================================
-- drop_table(:users)
   -> 0.0012s
== 20220920013221 CreateMovesTable: reverted (0.0039s) ========================
#+end_src

I then made the following revisions to the 'db/migrate/20220920013221_create_moves_table.rb' file with the following revisions:
#+begin_src ruby
class CreateMovesTable < ActiveRecord::Migration[6.1]
  def change
    create_table :moves do |t|
      t.string :pickup_location
      t.string :dropoff_location
    end
  end
end
#+end_src

I then re-migrated the tables accordingly:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake db:migrate
== 20220920013221 CreateMovesTable: migrating =================================
-- create_table(:moves)
   -> 0.0010s
== 20220920013221 CreateMovesTable: migrated (0.0011s) ========================

== 20220921003339 CreateItemsTable: migrating =================================
-- create_table(:items)
   -> 0.0010s
== 20220921003339 CreateItemsTable: migrated (0.0010s) ========================
#+end_src

<2022-09-23 Fri 11:06>: Related Notes From Office Hour:
- I need to utilize the 'collection.create()' method in this scenario so that I can create associated routes for the 'items' table itself since they need to piggyback off of the 'moves' table as per the 'has_many' Active Record macro:
- https://guides.rubyonrails.org/association_basics.html#methods-added-by-has-many-collection-create-attributes

<2022-09-28 Wed 18:35>: I also tested out the backend with this related rake command:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves $ bundle exec rake server
#+end_src

Using the port '9292', I was able to test the backend with Postman. However, I am having difficulties getting the 'PATCH' and 'DELETE' API endpoints to work.
* How I Created The Frontend Portion Of The Project
<2022-09-24 Sat 16:30>: I started with basic React app with the related 'npx create-react-app smoothmoves-frontend' command.

<2022-09-24 Sat 16:34>: I then referred to my previous notes in that you have to install 'v6' style routing components:
- https://reactrouter.com/docs/en/v6/getting-started/overview
I then used this command accordingly:
#+begin_src bash
npm install react-router-dom@6
#+end_src

Related output:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ ls
README.md               node_modules            package-lock.json       package.json            public                  src
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ npm install react-router-dom@6

added 3 packages, and audited 1453 packages in 3s

209 packages are looking for funding
  run `npm fund` for details

6 high severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
#+end_src

I then adjusted the contents of the '' file to include v6 style routes:
#+begin_src js
import logo from './logo.svg';
import './App.css';
import { Routes, Route } from "react-router-dom"

function App() {
  return (
    <div className="App">
      <Routes>
        <Route path="/" element={<About />}/>
        <Route path="/form" element={<Form />}/>
        <Route path="/checklist" element={<Checklist />}/>
        <Route path="/export" element={<Export />}/>
        <Route path="/email" element={<Email />}/>
      </Routes>
    </div>
  );
}

export default App;
#+end_src

<2022-09-24 Sat 16:47>: I then looked into including 'Material UI' as I know this is a CSS framework I always wanted to learn how to use, so I checked out their related installation guide:
- https://mui.com/material-ui/getting-started/installation/

I then did the following installation commands:
#+begin_src bash
npm install @mui/material @emotion/react @emotion/styled
#+end_src

Related output:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ pwd
/Users/samuelbanya/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ ls
README.md               node_modules            package-lock.json       package.json            public                  src
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ npm install @mui/material @emotion/react @emotion/styled

added 36 packages, and audited 1489 packages in 7s

217 packages are looking for funding
  run `npm fund` for details

6 high severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
#+end_src

I then noted that I needed to use the 'Roboto' font within any of the pages as well, so I made a note to use this stylesheet link on any page that needed it:
#+begin_src css
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
/>
#+end_src

I also made a note to include the related 'Material Icons' font as well on any page that needed it:
#+begin_src css
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/icon?family=Material+Icons"
/>
#+end_src

I then installed the related '@mui/icons-material' package with the following command:
#+begin_src bash
npm install @mui/icons-material
#+end_src

Related output:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend/smoothmoves-frontend $ npm install @mui/icons-material

added 1 package, and audited 1490 packages in 8s

218 packages are looking for funding
  run `npm fund` for details

6 high severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
#+end_src

<2022-09-24 Sat 17:30>: I then added the import statements for the planned components in the 'App.js' file:
#+begin_src js
import logo from './logo.svg';
import './App.css';
import { Routes, Route } from "react-router-dom"
import About from "./About"
import Form from "./Form"
import Checklist from "./Checklist"
import Export from "./Export"
import Email from "./Email"

function App() {
  return (
    <div className="App">
      <Routes>
        <Route path="/" element={<About />}/>
        <Route path="/form" element={<Form />}/>
        <Route path="/checklist" element={<Checklist />}/>
        <Route path="/export" element={<Export />}/>
        <Route path="/email" element={<Email />}/>
      </Routes>
    </div>
  );
}

export default App;
#+end_src

I then added the 'About.js' component which included the following inside of it:
#+begin_src js
import React from "react";

function About() {
    return (
        <div>
            <h2>About Page</h2>
            <p>
                This web app is a Full Stack web application made with React, Ruby, and Sinatra to help assist a U.S. based person to move via a related inventory sheet, and checklist which can be exported and shared with potential movers.
            </p>
            <h2>Functions</h2>
            <p>Actions that the user should be able to do include the following: </p>
            <ul>
                <li>
                    The ability for the user to tell the web app the two locations involved in their move (pickup location and dropoff location) which will be hooked up to a map based API to show markers, and total distance required in miles.
                </li>
                <li>
                    The ability for the user to go through each inventory item to determine its height, width, length, and weight of each box or individual item.
                </li>
                <li>
                    The ability for the user once they are done with this process to be shown the same checklist so that they can check each item off one by one.
                </li>
                <li>
                    The ability to then export this same checklist within a separate route as an Excel spreadsheet (.'.csv', or '.xlsx') to provide to actual movers.
                </li>
                <li>
                    The user can also fill out a form to then generate an email to be sent to the given mover as well.
                </li>
            </ul>
        </div>
    )
}

export default About;
#+end_src

I then added the following to the 'Checklist.js' component:
#+begin_src js
import React from "react";

function Checklist() {

}

export default Checklist;
#+end_src

I then added the following to the 'Email.js' component:
#+begin_src js
import React from "react";

function Email() {

}

export default Email;
#+end_src

I then added the following to the 'Export.js' component:
#+begin_src js
import React from "react"

function Export() {

}

export default Export;
#+end_src

I then added the following to the 'Form.js' component:
#+begin_src js
import React from "react";

function Form() {
    <div>
        <h2>Form</h2>
        <form>
            <div>
                <label htmlFor="pickupLocation"></label>
                <input />
                <label htmlFor="dropoffLocation"></label>
                <input />
                // NOTE: I need to iterate through the amount of items
                // that the user wants to enter, and therefore ask
                // them the following details for each item:
                // Height, width, length (inches, later converted to square feet)
                // Weight (lbs, pounds)
            </div>
            <br />
            <button className="uploadButton" type="submit">Upload</button>
        </form>
    </div>
}

export default Form;
#+end_src

<2022-09-26 Mon 16:42>: I then thought about it a bit further and realized I will need to somehow ask the user for the total amount of items they want to move, and iterate through that.

I believe this MIGHT need multiple forms within the same 'Form' components, but I might be wrong.

Regardless, I modified the 'Form.js' component with the following contents:
#+begin_src js
import React from "react";

function Form() {
    <div>
        <h2>Form</h2>
        <form>
            <div>
                <label htmlFor="pickupLocation"></label>
                <input />
                <label htmlFor="dropoffLocation"></label>
                <input />
                // NOTE: I need to iterate through the amount of items
                // that the user wants to enter, and therefore ask
                // them the following details for each item:
                // Height, width, length (inches, later converted to square feet)
                // Weight (lbs, pounds)
                <label htmlFor="itemAmount"></label>
                <input />
            </div>
            <br />
            <button className="uploadButton" type="submit">Upload</button>
        </form>
    </div>
}

export default Form;
#+end_src

<2022-09-26 Mon 16:44>: I then realized I needed to actually place all of the HTML based forms in the 'return' statement of the React component anyway, so I modified them accordingly.

<2022-09-26 Mon 20:31>: I then added the basic foundation for the other components including the 'Email.js' and 'Export.js' component since they are going to be React controlled forms as well.

<2022-09-27 Tue 20:00>: I did some research, and determined that since I want to use multi-step forms, this might be a great resource article to learn from since it has multiple screens with 'Next' and 'Previous' buttons to use in the form itself. This will involve multiple child components underneath the 'Form' parent, but I think it would be worth it for a more fluid user experience:
- https://dev.to/sametweb/how-to-create-multi-step-forms-in-react-3km4

<2022-09-29 Thu 11:38>: I used this article as a reference guide to make a form based upon Material-UI:
- https://onestepcode.com/creating-a-material-ui-form/

<2022-10-03 Mon 10:57>: This looks like two good reference links to use for creating a carousel type form for the item form itself:
- Related blog post on 'Carousel' component:
- https://statesnhooks.com/material-ui-carousel/
- Related blog post that includes a related demo of the 'Carousel' component itself:
- https://learus.github.io/react-material-ui-carousel/

<2022-10-03 Mon 11:00>: I then ran this related command to install the 'react-material-ui-carousel' component:
#+begin_src bash
npm install react-material-ui-carousel
#+end_src

Related output:
#+begin_src bash
samuelbanya@Samuels-MBP ~/hub/Development/code/phase-3/SmoothMoves-Frontend $ npm install react-material-ui-carousel

added 8 packages, and audited 1498 packages in 5s

218 packages are looking for funding
  run `npm fund` for details

6 high severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
#+end_src

<2022-10-03 Mon 12:42>: Notes From Office Hour:
- I need '/moves/new' for the '/moveform' route
- I can also maybe use a '/moves/show' route, that would show each individual route, and you can then work on that given move to build a collection of items.
- We would use use 'moves/:id' to access a given move that we created via the
- I then create a separate 'ItemForm' component for the '/items' where the user could be prompted for how many items are associated with that given move
- Then, I could create a child component called 'Item' which would contain each individual 'carousel' form that I could fill out individually
- I would then maybe have to use the idea of 'nested' forms to pull this off

<2022-10-03 Mon 18:49>: I used this video as a guide up until timestamp, '1:01:34', since I think her usage of how she handled an 'Edit' functionality just looks plain awkward, and wouldn't make sense in my current workflow:
- SE - Live - 101121 - Phase 2 - forms:
- https://vimeo.com/642855398

<2022-10-03 Mon 19:24>: I also referred to this video as a guide for understanding 'State' as recommended during the second Office Hour I attended today.

<2022-10-04 Tue 11:47>: One major issue that I resolved today was how to pass down props with 'V6' style React routing which is different than what we originally learned in the course, and wasn't taught directly.

I took a look through the 'App.js' parent component, as well as the 'MoveForm.js' child component and tried to figure out why the props weren't being sent down properly.

I printed out the props on the parent 'App.js' component level as well as the child 'MoveForm.js' component level, and realized that 'moveFormData' wasn't even being sent down properly.

I then made this revision to 'App.js' which resolved this issue:
#+begin_src js
import logo from './logo.svg';
import './App.css';
import { Routes, Route } from "react-router-dom"
import About from "./About"
import MoveForm from "./MoveForm"
import ItemForm from "./ItemForm"
import Checklist from "./Checklist"
import Export from "./Export"
import Email from "./Email"
import NavBar from "./NavBar"
import React, {useState} from "react";

function App() {
  const [moveList, setMoveList] = useState([{pickupLocation: "", dropoffLocation: ""}]);

  const [moveFormData, setMoveFormData] = useState({
    pickupLocation: "",
    dropoffLocation: ""
  });

  console.log("moveFormData (from parent App component): ", moveFormData);

  const handleMoveChange = (e) => {
      // NOTE: This is the same as using obj2 = {...obj1, name: "Sam"}
      // This is because we are utilizing the existing data by using the spread operator:
      setMoveFormData({...moveFormData, [e.target.name]: e.target.value});
  };
  // fetch(("https://localhost:9292/moves"), {
  //     method: "POST",
  //     headers: {
  //         "Content-Type": "application/json",
  //     },
  //     body: JSON.stringify(formValues),
  // });
  // .then((response) => response.json())
  // .then((data) => {
  //     console.log("data: ", data);
  // })

  const handleMoveFormSubmit = (e) => {
    e.preventDefault();
    setMoveList([moveFormData, ...moveList]);
    // NOTE: This clears the form data upon each submission:
    setMoveFormData({
        pickupLocation: "",
        dropoffLocation: ""
    });
  }

  return (
    <div className="App">
      <NavBar />
      <Routes>
        <Route path="/" element={<About />}/>
        <Route path="/moves" element={<MoveForm handleMoveFormSubmit={handleMoveFormSubmit} moveFormData={moveFormData} handleMoveChange={handleMoveChange} />}/>
        <Route path="/items" element={<ItemForm />}/>
        <Route path="/checklist" element={<Checklist />}/>
        <Route path="/export" element={<Export />}/>
        <Route path="/email" element={<Email />}/>
      </Routes>
    </div>
  );
}

export default App;
#+end_src

<2022-10-04 Tue 14:40>: I fixed the issue I had with my POST request not working by simplifying it a bit. I used Postman, and realized that each 'POST' request really just needs a single object with the required values.

The way that the lab had done it was a bit excessive since each individual form's values represents a specific move's data.

Therefore, I modified the parent 'App.js' component to include the following:
#+begin_src js
import logo from './logo.svg';
import './App.css';
import { Routes, Route } from "react-router-dom"
import About from "./About"
import MoveForm from "./MoveForm"
import ItemForm from "./ItemForm"
import Checklist from "./Checklist"
import Export from "./Export"
import Email from "./Email"
import NavBar from "./NavBar"
import React, {useState} from "react";

function App() {
  // const [moveList, setMoveList] = useState([{pickupLocation: "", dropoffLocation: ""}]);

  const [moveFormData, setMoveFormData] = useState({
    pickupLocation: "",
    dropoffLocation: ""
  });

  console.log("moveFormData (from parent App component): ", moveFormData);

  const handleMoveChange = (e) => {
      // NOTE: This is the same as using obj2 = {...obj1, name: "Sam"}
      // This is because we are utilizing the existing data by using the spread operator:
      setMoveFormData({...moveFormData, [e.target.name]: e.target.value});
  };

  const handleMoveFormSubmit = (e) => {
    e.preventDefault();
    // NOTE: This is the single lin that is causing the issue I am having since I need to just create an individual move based object, not a list of them
    // setMoveList([moveFormData, ...moveList]);
    // setMoveFormData(moveFormData);
    console.log("moveFormData inside POST request: ", moveFormData);
    fetch("http://localhost:9292/moves", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
      // NOTE: I had to convert "pickupLocation" and "dropoffLocation" variables from the React frontend
      // to the "pickup_location", and "dropoff_location" Ruby backend variable names by using destructuring:

      // Related MDN reference:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
      body: JSON.stringify({ "pickup_location": moveFormData["pickupLocation"], "dropoff_location": moveFormData["dropoffLocation"] }),
    })
    .then((response) => response.json())
    .then((data) => {
      console.log("data: ", data);
      // NOTE: This clears the form data upon each submission:
      // console.log("Clearing form...")
      // setMoveFormData({
      //     pickupLocation: "",
      //     dropoffLocation: ""
      // });
    });
  }

  return (
    <div className="App">
      <NavBar />
      <Routes>
        <Route path="/" element={<About />}/>
        <Route path="/moves" element={<MoveForm handleMoveFormSubmit={handleMoveFormSubmit} moveFormData={moveFormData} handleMoveChange={handleMoveChange} />}/>
        <Route path="/items" element={<ItemForm />}/>
        <Route path="/checklist" element={<Checklist />}/>
        <Route path="/export" element={<Export />}/>
        <Route path="/email" element={<Email />}/>
      </Routes>
    </div>
  );
}

export default App;
#+end_src

<2022-10-05 Wed 19:34>: I searched for a few examples that utilized the 'react-material-ui-carousel' library, and found these projects:
- https://codesandbox.io/examples/package/react-material-ui-carousel

I then used this CodeSandbox as an example to implement the '<Carousel>' tag into my project:
- https://codesandbox.io/s/zx6om

I then opted to use the '<NativeSelect>' tag for the 'item_type' property for each item as it was a bit simpler to use as per their related example from the Material UI docs page:
- https://mui.com/material-ui/react-select/#native-select

I also did some research on the '<Carousel>' tag's properties, and determined you can set the interval to a null value:
- https://stackoverflow.com/questions/66110845/how-to-turn-off-autoplay-for-react-bootstrap-carousel

Related null value example:
#+begin_src js
<Carousel interval={null}></Carousel>
#+end_src

Related example:
#+begin_src js
import * as React from 'react';
import Box from '@mui/material/Box';
import InputLabel from '@mui/material/InputLabel';
import FormControl from '@mui/material/FormControl';
import NativeSelect from '@mui/material/NativeSelect';

export default function NativeSelectDemo() {
  return (
    <Box sx={{ minWidth: 120 }}>
      <FormControl fullWidth>
        <InputLabel variant="standard" htmlFor="uncontrolled-native">
          Age
        </InputLabel>
        <NativeSelect
          defaultValue={30}
          inputProps={{
            name: 'age',
            id: 'uncontrolled-native',
          }}
        >
          <option value={10}>Ten</option>
          <option value={20}>Twenty</option>
          <option value={30}>Thirty</option>
        </NativeSelect>
      </FormControl>
    </Box>
  );
}
#+end_src

<2022-10-05 Wed 19:35>: I also did a major overhaul to only incorporate 'MoveItem' and 'ItemForm' components as per the '/moves' and '/items' routes to meet the project's requirements.

The biggest Catch 22 I have faced in this project was being able to try to figure out the 'UPDATE' button on the 'Edit Existing Move' section on the 'Move' component of the project.

I tried doing some research and only found this StackOverflow post which basically just uses a Controlled Form example:
- https://stackoverflow.com/questions/35791074/reactjs-how-can-i-set-a-value-for-textfield-from-material-ui

I then did further digging and found a GitHub issue for React itself that mentions that you can even forgo the idea of using 'value' but at the cost of making it a non-controlled form:
- https://github.com/facebook/react/issues/8053

<2022-10-05 Wed 19:50>: The major issues that I still have for today include the following:
The 'MoveForm' component:
FIXED: 1. The 'Move > "Edit Existing Move" > DELETE' button doesn't work to actually delete a given move --> <2022-10-06 Thu 13:56>: I resolved this issue, though it does produce this in console:
#+begin_src bash
VM594:1 Uncaught (in promise) SyntaxError: Unexpected end of JSON input
    at App.js:98:1
#+end_src

I also tried using this lesson as a reference as well:
- https://learning.flatironschool.com/courses/5286/assignments/172832?module_item_id=376873

I got this to delete the given move, but it doesn't actually delete the data until I refresh the page.

I tried researching the above error, and found a related StackOverflow post about a few people complaining about CORS errors when using ExpressJS to deploy their projects:
- https://stackoverflow.com/questions/43362431/uncaught-in-promise-syntaxerror-unexpected-end-of-json-input

I also tried using this lesson as a reference as well:
- https://learning.flatironschool.com/courses/5286/assignments/172832?module_item_id=376873

2. The 'Move > "Edit Existing Move" > dropdown list' does not update any new locations until I refresh the page.

3. The 'Move > "Edit Existing Move" > UPDATE' button doesn't work since I can't edit the 'Pickup Location' and 'Dropoff Location' based '<TextField>' Material UI tags since they're controlled by the 'value' property, which is supposed to be controlled by default. In order to make them uncontrolled, 'defaultValue' can be used, but this doesn't seem to work either.

<2022-10-06 Thu 14:04>: Related research on this:
- StackOverflow post:
- https://stackoverflow.com/questions/46118340/i-cant-edit-text-field-in-material-ui
- Section from StackOverFlow post above that mentions this:
#+begin_src text
If you pass value as a prop to TextField you can't change that text! On Material-UI official documentation they have used defaultValue="default val" as a prop. So I used defaultValue as a prop! It worked fine for me!
#+end_src
#+begin_src js
<TextField
   type="text"
   defaultValue={this.props.val}
   onChange={handleChange}
/>
#+end_src

The 'ItemForm' component:
4. I really don't know how I will be able to associate a 'Move' with corresponding 'Items' since you can enter in the amount of items and keep changing the 'Choose Move' dropdown, which isn't that great since this means you can't edit a specific move's items later on or delete them

5. The 'Items > SUBMIT ALL ITEMS' button needs validation to ensure that each item has everything filled out before submission.

6. I am not sure how to aggregate all of the data I have entered within the '<Carousel>' items I created within the 'Item' form to make a 'POST' request to the backend. The only thing I can think of is to associate the 'item #' or 'id' value with a specific 'id' value for each item.

Aka I would have to loop through each of the items, and make a 'POST' request for each one somehow. Not sure if this idea would be resource intensive but it seems like the way to go.

FIXED: 7. When you refresh the page for the 'Items' route, there is a ghosted artifact button for the 'Enter Item Info' section. This is because I am conditionally rendering the '<Button>' tag for the 'Submit All Items' section.

<2022-10-05 Wed 20:19>: NOTE: I fixed this issue by literally setting the secondary value for the ternary statement to 'null':
#+begin_src js
{ itemsCarouselArray.length > 1 ? <Button variant="contained" color="primary" type="submit">Submit All Items</Button> : null}
#+end_src

<2022-10-06 Thu 10:43>: These are three major suggestions for solutions towards some of the issues I've been having with this project that I thought of as I was trying to sleep last night:
Idea 1:
- Fix the 'UPDATE' portion of the 'Move' component so that I can at least get full credit for 1 model for a CRUD method at the bare minimum
- Screw the idea of using a React controlled form in this scenario since there is nothing within the project requirements that states that I NEED to use a React controlled form
- Using a React controlled form is ideal, but in this scenario, it is only working against me
- The only thing I can think of to do this kind of action would be when the 'Move > Edit Existing Move >' select dropdown is changed via the 'useEffect()' hook, I should manually change the values of the 'Pickup Location' and 'Dropoff Location' sections accordingly by using 'document.getElementById()' and changing the 'defaultValue' properties of the fields accordingly --> OR even change them to normal <input> tags anyway to make it even easier and less dependent on Material UI
- Another idea would be to literally allow the user to swap the 'pickup_location' and 'dropoff_location' with a 'SWAP LOCATION' button so that I can manually swap the values via a callback function to the parent 'App.js' component

Idea 2:
- Figure out how to make the Move > 'Edit Existing Move' > 'DELETE' button actually work with the Ruby based backend

Idea 3:
- Figure out how to manage the routing situation for the 'Items' route aka 'ItemForm' component
- The only thing I can think of is that instead of going off the user input for the Items > 'Item Amount' input field with looping, I should instead ACTUALLY call the backend to create the 'id' instances of each individual move / items route
- How to do this, I have zero clue
- I would need to also incorporate input validation to prevent the user from entering in an amount without selecting a move from the 'Select dropoff location'
- However, once this is entered, this would then trigger a 'GET' request from the backend to display the current selected move's newly created 'items' from the backend

<2022-10-06 Thu 20:55>: After a ton of refactoring, the main issues with this project for basic functionality that still remain include the following:
1. Move > 'Edit Existing Move' > 'UPDATE' button does not work
2. Move > 'Edit Existing Move' > 'DELETE' button only works upon refreshing the page
3. Items > 'Enter Item Info' > 'Item # (number)' > 'DELETE' button doesn't work
4. Items > 'Enter Item Info' > 'Item # (number)' > 'SUBMIT ALL ITEMS' doesn't work since I'm not sure how to handle all of the data from the <Carousel> item data I have collected so far

<2022-10-07 Fri 11:07>: Notes for the workflow on how to create the 'Items' component's API calls to the backend:
- Items is an array
#+begin_src js
const newItems = [...move.items, item]
#+end_src
- With 'move', update state for 'move' --> find the move
- Once you find the move, reach into the 'moves' array which is in state
#+begin_src js
const updatedMove = {...move, items: newItems}
const updatedMoves = moves.map((move) => move.id === updatedMove.id ? updatedMove : move);
setMoves(updatedMoves);
#+end_src

<2022-10-07 Fri 11:38>: Another note on how to make sure the 'Move' > Edit Existing Move > DELETE button:
- I need to make sure it updates state in the same fashion as what I did for the UPDATE button in the same section

<2022-10-08 Sat 21:15>: I made the choice to pullback my idea of using the 'item_type' property on the backend for the 'Item' table.

Reason being is that in the overall workflow of the app itself, it actually doesn't even matter if the item is boxed or loose.

I could literally make 19 items that are 'boxes' in the 'name' property value itself, and include 1 loose item.

Realistically, you can create 19 boxes, and then 1 or 2 loose items, and you would be fine since the moving company only really cares about the dimensions of items and their associated weight.

<2022-10-08 Sat 21:39>: I then decided to refactor my 'ItemsForm' to include the multiple functions as functions within the 'ItemsForm' component itself. Reason being is that passing props up and down is very hard in this scenario, and I just want things to work without being too confusing here.

It's worth another refactor later, but to make sure I get this project done in time, this is the way we're going to get this to work for the time being.

<2022-10-08 Sat 22:17>: I then decided to still keep "ItemCard" as its own React component because ultimately, it is returning some complicated JSX output as its own thing, so it really deserves its own component.

I also figured out how to use the callback function so that I could send data from the child to the parent component, as this is the only way to do this in React aka via a callback function in the first place.

It's slightly awkward in structure, but I think this meets the overall accepted React controlled form design flow without having to be too confusing to be able to come back to later anyway.

<2022-10-08 Sat 22:26>: I realized I made a huge mistake in that if I set the form data on the parent level, then each individual 'ItemCard' component is updated to a SINGLE set of form data, as opposed to having their own individual data values.

I need to somehow figure out how to aggregate the data present so that I can send it up to the parent 'ItemsForm' component to make the appropriate POST requests to the backend to create each individual call to the '/moves/:id/items' API endpoint.

<2022-10-08 Sat 23:57>: I did more research, and this is the only kind of example that somewhat got close, but they ultimately just used callback functions in the parent component anyway, and it still doesn't have multiple forms within a parent component:
- https://www.agirl.codes/complete-guide-build-react-forms-with-usestate-hook


<2022-10-09 Sun 16:33>: I refactored my components so that 'moves' is only called via 'useEffect' once within the parent 'App.js' component level to avoid having to use duplicative work in both the 'Moves' and 'Items' child components.

This is the major revision I did within the parent 'App.js' component level accordingly which I passed the 'moves' useState variable down as props to the child components:
#+begin_src js
import logo from './logo.svg';
import './App.css';
import { Routes, Route } from "react-router-dom";
import About from "./components/generalComponents/About";
import Moves from "./components/moveComponents/Moves";
import Items from "./components/itemComponents/Items";
import NavBar from "./components/generalComponents/NavBar";
import React, { useState, useEffect } from "react";

function App() {
  const [moves, setMoves] = useState([]);
  useEffect(() => {
      fetch("http://localhost:9292/moves", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json",
        },
      })
      .then((response) => response.json())
      .then((data) => {
        setMoves(data);
      })
    }, [moves]);

  return (
    <div className="App">
      <NavBar />
      <Routes>
        <Route path="/" element={<About />}/>
        <Route path="/moves"
          element={<Moves moves={moves} setMoves={setMoves}/>}
        />
        <Route path="/items"
          element={<Items moves={moves}/>}
        />
      </Routes>
    </div>
  );
}

export default App;
#+end_src

I also revised the backend so that I excluded the previous 'DELETE' and 'PATCH' methods for the 'Items' table itself because the workflow I have for my current app doesn't need the items to be revised or edited as this is the frontend's job to do so BEFORE the final submission is made.
